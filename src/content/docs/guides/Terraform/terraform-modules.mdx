---
title: "Terraform Modules"
description: "Learn how to use Terraform modules to create reusable, maintainable infrastructure components."
sidebar:
  label: "Terraform Modules"
  order: 4
  badge:
    text: "Mid"
    variant: "caution"
tableOfContents: true
---

import { Aside, Badge, Steps } from "@astrojs/starlight/components";
import Quiz from "../../../../components/Quiz.astro";
import Flashcard from "../../../../components/Flashcard.astro";
import ProgressCheck from "../../../../components/ProgressCheck.astro";

<Badge text="Terraform" class="terraform" />

Modules are containers for multiple resources that are used together. They let you create reusable infrastructure components and simplify complex deployments that span multiple APIs or services.

<Aside type="tip" title="Think of Modules as Functions">
  Just like functions in programming, modules take inputs (variables), create
  resources, and return outputs. They make your code DRY (Don't Repeat Yourself)
  and easier to maintain.
</Aside>

---

## Why Use Modules?

| Benefit             | Description                           |
| ------------------- | ------------------------------------- |
| **Reusability**     | Define once, use many times           |
| **Abstraction**     | Hide complex implementation details   |
| **Consistency**     | Ensure standard configurations        |
| **Maintainability** | Update in one place, apply everywhere |
| **Collaboration**   | Share modules across teams            |

---

## The Problem: Manual Resource Creation

Without modules, creating a VPC with all its components requires many resource blocks:

```hcl
# VPC
resource "aws_vpc" "vpc" {
  cidr_block = "10.0.0.0/16"
  tags = {
    Name = "devhub-vpc"
  }
}

# Public Subnet
resource "aws_subnet" "public" {
  vpc_id            = aws_vpc.vpc.id
  cidr_block        = "10.0.1.0/24"
  availability_zone = "ca-central-1a"
  tags = {
    Name = "devhub-public"
  }
}

# Internet Gateway
resource "aws_internet_gateway" "ig" {
  vpc_id = aws_vpc.vpc.id
}

# Route Table
resource "aws_route" "route" {
  route_table_id         = aws_vpc.vpc.default_route_table_id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.ig.id
}
```

This is verbose, error-prone, and must be repeated for every environment.

---

## The Solution: Using Modules

With the AWS VPC module, all of that becomes:

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "module-vpc-${var.user}"
  cidr = "10.${var.user}.0.0/16"

  azs             = ["ca-central-1a", "ca-central-1b", "ca-central-1d"]
  private_subnets = ["10.${var.user}.2.0/24", "10.${var.user}.3.0/24"]
  public_subnets  = ["10.${var.user}.1.0/24"]

  enable_nat_gateway = true
  single_nat_gateway = true

  tags = {
    Terraform   = "true"
    Environment = "dev"
  }
}
```

<Flashcard
  title="Module Benefits"
  cards={[
    {
      front: "What are the main benefits of using Terraform modules?",
      back: "1. Reusability - Use the same module multiple times. 2. Abstraction - Hide complex details. 3. Consistency - Standard configurations. 4. Maintainability - Update once, apply everywhere. 5. Community - Use pre-built modules from the registry",
    },
  ]}
/>

---

## Module Sources

Modules can come from various sources:

| Source             | Example                                       |
| ------------------ | --------------------------------------------- |
| Terraform Registry | `terraform-aws-modules/vpc/aws`               |
| GitHub             | `github.com/org/repo`                         |
| Local Path         | `./modules/vpc`                               |
| S3 Bucket          | `s3::https://bucket.s3.amazonaws.com/vpc.zip` |
| Git                | `git::https://example.com/repo.git`           |

### Using Registry Modules

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"  # Always pin versions!

  # Module inputs...
}
```

### Using Local Modules

```hcl
module "my_vpc" {
  source = "./modules/vpc"

  # Module inputs...
}
```

---

## Creating Your Own Module

### Module Structure

```
modules/
└── web-server/
    ├── main.tf         # Resources
    ├── variables.tf    # Input variables
    ├── outputs.tf      # Output values
    └── README.md       # Documentation
```

### modules/web-server/variables.tf

```hcl
variable "name" {
  type        = string
  description = "Name tag for resources"
}

variable "instance_type" {
  type        = string
  default     = "t2.micro"
  description = "EC2 instance type"
}

variable "subnet_id" {
  type        = string
  description = "Subnet ID for the instance"
}

variable "security_group_ids" {
  type        = list(string)
  description = "Security group IDs"
}
```

### modules/web-server/main.tf

```hcl
data "aws_ami" "ubuntu" {
  most_recent = true

  filter {
    name   = "name"
    values = ["ubuntu/images/*/ubuntu-*-22.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }

  owners = ["099720109477"]
}

resource "aws_instance" "web" {
  ami                    = data.aws_ami.ubuntu.id
  instance_type          = var.instance_type
  subnet_id              = var.subnet_id
  vpc_security_group_ids = var.security_group_ids

  tags = {
    Name = var.name
  }
}
```

### modules/web-server/outputs.tf

```hcl
output "instance_id" {
  value       = aws_instance.web.id
  description = "The EC2 instance ID"
}

output "public_ip" {
  value       = aws_instance.web.public_ip
  description = "The public IP address"
}

output "private_ip" {
  value       = aws_instance.web.private_ip
  description = "The private IP address"
}
```

---

## Using Your Module

```hcl
# main.tf

module "web_server_1" {
  source = "./modules/web-server"

  name               = "devhub-web-1"
  instance_type      = "t2.micro"
  subnet_id          = module.vpc.public_subnets[0]
  security_group_ids = [aws_security_group.web.id]
}

module "web_server_2" {
  source = "./modules/web-server"

  name               = "devhub-web-2"
  instance_type      = "t2.small"
  subnet_id          = module.vpc.public_subnets[0]
  security_group_ids = [aws_security_group.web.id]
}

# Access module outputs
output "web1_ip" {
  value = module.web_server_1.public_ip
}

output "web2_ip" {
  value = module.web_server_2.public_ip
}
```

---

## Module Workflow

<Steps>

1. **Initialize modules**

   After adding or updating module sources:

   ```bash
   terraform init
   ```

2. **Upgrade modules**

   To update to newer versions:

   ```bash
   terraform init -upgrade
   ```

3. **Plan and apply**

   ```bash
   terraform plan
   terraform apply
   ```

</Steps>

---

## Popular Registry Modules

| Module                                   | Description                        |
| ---------------------------------------- | ---------------------------------- |
| `terraform-aws-modules/vpc/aws`          | AWS VPC with subnets, NAT, routing |
| `terraform-aws-modules/ec2-instance/aws` | EC2 instances                      |
| `terraform-aws-modules/rds/aws`          | RDS databases                      |
| `terraform-aws-modules/s3-bucket/aws`    | S3 buckets                         |
| `terraform-aws-modules/eks/aws`          | Kubernetes clusters                |

Browse more at [registry.terraform.io](https://registry.terraform.io/)

---

## Best Practices

1. **Always pin module versions** - Avoid unexpected changes
2. **Use semantic versioning** - `~> 5.0` allows `5.x` updates
3. **Document your modules** - Include README.md
4. **Keep modules focused** - One purpose per module
5. **Use outputs** - Expose values other resources need

<Aside type="caution" title="Version Pinning">
  Without version pinning, `terraform init` might download breaking changes.
  Always specify: `version = "~> 5.0"` or `version = "5.1.2"`
</Aside>

---

## Knowledge Check

<Quiz
  question="What is a Terraform module?"
  options={[
    "A single .tf file",
    "A container for multiple related resources",
    "A Terraform plugin",
    "A state file",
  ]}
  correct={1}
  explanation="A module is a container for multiple resources that are used together, allowing for reusable infrastructure components."
/>

<Quiz
  question="Where can modules be sourced from?"
  options={[
    "Only Terraform Registry",
    "Only local paths",
    "Only GitHub",
    "Registry, local, GitHub, S3, and more",
  ]}
  correct={3}
  explanation="Modules can come from the Terraform Registry, local paths, Git repositories, S3 buckets, and other sources."
/>

<Quiz
  question="What command updates module versions?"
  options={[
    "terraform get",
    "terraform init -upgrade",
    "terraform update",
    "terraform refresh",
  ]}
  correct={1}
  explanation="terraform init -upgrade downloads the latest versions of modules within version constraints."
/>

---

## Progress Checklist

<ProgressCheck
  id="terraform-modules"
  title="Terraform Modules Checklist"
  items={[
    "Understand why modules are useful",
    "Use a module from the Terraform Registry",
    "Create your own local module",
    "Use module outputs in other resources",
    "Pin module versions",
  ]}
/>

---

## Save Your Progress

```bash
git add .
git commit -m "Terraform modules"
git push
```

---

## Source

Based on HashiCorp Terraform documentation and DevHub examples.
